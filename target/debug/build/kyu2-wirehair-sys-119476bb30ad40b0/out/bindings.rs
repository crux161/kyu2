/* automatically generated by rust-bindgen 0.69.5 */

#[doc = " Success code"]
pub const WirehairResult_t_Wirehair_Success: WirehairResult_t = 0;
#[doc = " More data is needed to decode.  This is normal and does not indicate a failure"]
pub const WirehairResult_t_Wirehair_NeedMore: WirehairResult_t = 1;
#[doc = " A function parameter was invalid"]
pub const WirehairResult_t_Wirehair_InvalidInput: WirehairResult_t = 2;
#[doc = " Encoder needs a better dense seed"]
pub const WirehairResult_t_Wirehair_BadDenseSeed: WirehairResult_t = 3;
#[doc = " Encoder needs a better peel seed"]
pub const WirehairResult_t_Wirehair_BadPeelSeed: WirehairResult_t = 4;
#[doc = " N = ceil(messageBytes / blockBytes) is too small.\n Try reducing block_size or use a larger message"]
pub const WirehairResult_t_Wirehair_BadInput_SmallN: WirehairResult_t = 5;
#[doc = " N = ceil(messageBytes / blockBytes) is too large.\n Try increasing block_size or use a smaller message"]
pub const WirehairResult_t_Wirehair_BadInput_LargeN: WirehairResult_t = 6;
#[doc = " Not enough extra rows to solve it, must give up"]
pub const WirehairResult_t_Wirehair_ExtraInsufficient: WirehairResult_t = 7;
#[doc = " An error occurred during the request"]
pub const WirehairResult_t_Wirehair_Error: WirehairResult_t = 8;
#[doc = " Out of memory"]
pub const WirehairResult_t_Wirehair_OOM: WirehairResult_t = 9;
#[doc = " Platform is not supported yet"]
pub const WirehairResult_t_Wirehair_UnsupportedPlatform: WirehairResult_t = 10;
#[doc = " Platform is not supported yet"]
pub const WirehairResult_t_WirehairResult_Count: WirehairResult_t = 11;
#[doc = " Platform is not supported yet"]
pub const WirehairResult_t_WirehairResult_Padding: WirehairResult_t = 2147483647;
#[doc = " These are the result codes that can be returned from the API functions"]
pub type WirehairResult_t = ::std::os::raw::c_uint;
#[doc = " These are the result codes that can be returned from the API functions"]
pub use self::WirehairResult_t as WirehairResult;
extern "C" {
    #[doc = " Get WirehairResult string function"]
    pub fn wirehair_result_string(result: WirehairResult) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "wirehair_init()\n\nVerify binary compatibility with the API on startup.\n\nExample:\nif (wirehair_init()) {\nexit(1);\n}\n\nReturns Wirehair_Success on success.\nReturns other codes on error."]
    pub fn wirehair_init_(expected_version: ::std::os::raw::c_int) -> WirehairResult;
}
#[doc = " WirehairCodec: From wirehair_encoder_create() or wirehair_decoder_create()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WirehairCodec_t {
    pub impl_: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_WirehairCodec_t() {
    const UNINIT: ::std::mem::MaybeUninit<WirehairCodec_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<WirehairCodec_t>(),
        1usize,
        concat!("Size of: ", stringify!(WirehairCodec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<WirehairCodec_t>(),
        1usize,
        concat!("Alignment of ", stringify!(WirehairCodec_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WirehairCodec_t),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " WirehairCodec: From wirehair_encoder_create() or wirehair_decoder_create()"]
pub type WirehairCodec = *mut WirehairCodec_t;
extern "C" {
    #[doc = "wirehair_encoder_create()\n\nEncode the given message into blocks of size blockBytes.\n\nThe number of blocks in the message:\nN = (bytes + (blockBytes-1)) / blockBytes\n\nIf N is too high or too low this function will fail.  In particular if N = 1, then\nusing this type of error correction does not make sense: Sending the same message\nover and over is just as good.  And if N > 64000 then some internal variables will\nstart to overflow, so too many blocks is unsupported.  The most efficient values\nfor N are around 1000.\n\nPreconditions:\nN >= 2\nN <= 64000\n\nPass 0 for reuseOpt if you do not want to reuse a WirehairCodec object.\n\nReturns a non-zero object pointer on success.\nReturns nullptr(0) on failure."]
    pub fn wirehair_encoder_create(
        reuseOpt: WirehairCodec,
        message: *const ::std::os::raw::c_void,
        messageBytes: u64,
        blockBytes: u32,
    ) -> WirehairCodec;
}
extern "C" {
    #[doc = "wirehair_encode()\n\nWrite an error correction block.\n\nThe first `blockId` < N blocks are the same as the input data.\nThis \"systematic\" property can be used to run the encoder\nin parallel with sending original data.\nThe `blockId` >= N blocks are generated on demand.\n\nPreconditions:\nBlock is at least `blockBytes` in size\n\nReturns Wirehair_Success on success.\nReturns other codes on error."]
    pub fn wirehair_encode(
        codec: WirehairCodec,
        blockId: ::std::os::raw::c_uint,
        blockDataOut: *mut ::std::os::raw::c_void,
        outBytes: u32,
        dataBytesOut: *mut u32,
    ) -> WirehairResult;
}
extern "C" {
    #[doc = "wirehair_decoder_create()\n\nInitialize a decoder for a message of size bytes with blockBytes bytes\nper received block.  These parameters should match the ones passed to\nthe corresponding wirehair_encoder_create() call.\n\nPass 0 for reuseOpt if you do not want to reuse a WirehairCodec object.\n\nReturns a non-zero object pointer on success.\nReturns nullptr(0) on failure."]
    pub fn wirehair_decoder_create(
        reuseOpt: WirehairCodec,
        messageBytes: u64,
        blockBytes: u32,
    ) -> WirehairCodec;
}
extern "C" {
    #[doc = "wirehair_decode()\n\nProvide the decoder with a block from the wirehair_encode() function.\n\nPreconditions:\nThe application must not provide duplicate data for the same packet.\nIn other words, blockId values cannot be used twice.\n\nReturns Wirehair_Success if data recovery is complete.\n+ Use wirehair_recover() or wirehair_recover_block()\nto reconstruct the recovered data.\nReturns Wirehair_NeedsMoreData if more data is needed to decode.\nReturns other codes on error."]
    pub fn wirehair_decode(
        codec: WirehairCodec,
        blockId: ::std::os::raw::c_uint,
        blockData: *const ::std::os::raw::c_void,
        dataBytes: u32,
    ) -> WirehairResult;
}
extern "C" {
    #[doc = "wirehair_recover()\n\nReconstruct the message after reading is complete.\n\nPreconditions:\nMessage contains enough space to store the entire decoded message (bytes)\n\nReturns Wirehair_Success if the message was recovered.\nReturns other codes on error."]
    pub fn wirehair_recover(
        codec: WirehairCodec,
        messageOut: *mut ::std::os::raw::c_void,
        messageBytes: u64,
    ) -> WirehairResult;
}
extern "C" {
    #[doc = "wirehair_recover_block()\n\nReconstruct a single block of the message after reading is complete.\nIt is much slower than wirehair_recover() for original data, so it\nis better to avoid calling this function for blockId < N.\n\nPreconditions:\nBlock ptr buffer contains enough space to hold the block (blockBytes)\n\nMay return non-zero to indicate a failure.\n\nReturns Wirehair_Success if the block was recovered.\nReturns other codes on error."]
    pub fn wirehair_recover_block(
        codec: WirehairCodec,
        blockId: ::std::os::raw::c_uint,
        blockData: *mut ::std::os::raw::c_void,
        bytesOut: *mut u32,
    ) -> WirehairResult;
}
extern "C" {
    #[doc = "wirehair_decoder_becomes_encoder()\n\nConvert a decoder WirehairCodec into an encoder WirehairCodec\nafter recovery is complete.  This enables the application to\nreceive a message and then retransmit it without reinitializing\nthe encoder from scratch.\n\nNote that after converting the codec to an encoder, calling the\nwirehair_encode() function to retrieve original data will be\nmuch slower than accessing the original data directly on the\napplication side.\n\nPreconditions:\nwirehair_decoder_read() returned Wirehair_Success\n\nReturns Wirehair_Success if the operation was successful.\nReturns other codes on error."]
    pub fn wirehair_decoder_becomes_encoder(codec: WirehairCodec) -> WirehairResult;
}
extern "C" {
    #[doc = "wirehair_free()\n\nFree memory associated with a WirehairCodec object."]
    pub fn wirehair_free(codec: WirehairCodec);
}
